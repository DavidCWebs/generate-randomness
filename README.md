Randomness in Linux
===================
This project uses various methods to generate pseudo random numbers/strings that are cryptograpically secure.

Random numbers have many important uses in applied cryptography. Yet you can't compute true randomness arithmetically:

>Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin. For, as has been pointed out several times, there is no such thing as a random number â€” there are only methods to produce random numbers, and a strict arithmetic procedure of course is not such a method.
>[John Von Neumann][4]

Computers are deterministic - and predictable. So you can't expect a computer to produce randomness arithmetically. There are many "random" number generators built into programming languages, but these usually produce outputs that have a flavour of randomness - they are not cryptographically secure. You should NOT use such methods to generate random numbers that will be used for non-trivial purposes (e.g. generating private keys).

This repo contrasts random number generation by mean of different userspace libraries and accessing `/dev/urandom` directly. `/dev/urandom` is the interface to the Linux kernel random number generator.

At the moment, I've included random number generation by means of the libgcrypt and openssl userspace libraries.

/dev/urandom as a source of Randomness
--------------------------------------
`/dev/urandom` is a character special file in Linux (including Android) and other \*NIXes that provides access to a source of randomness generated by the Kernel. The randomness is sourced from environmental noise from device drivers and other sources - stored in an entropy pool.

* Has access to raw device entropy
* Won't share state between applications

Most userspace random number generators ultimately rely on `/dev/urandom` in any case - so in your own applications you should consider accessing the API directly rather than through a userspace library like openSSL or libgcrypt.

Access /dev/urandom in C
------------------------
A pretty simple way to access `/dev/urandom` randomness in C is to `fopen()` the file and read the required number of bytes. See [urandom-c/main.c][9]. 

Randomness in BASH
------------------
You can get good randomness directly from within bash - the `/dev/random`/`/dev/urandom` files provide easy access to good random numbers.

For cryptographically secure random numbers suitable for most applications, grab bytes from `/dev/urandom`. You can then represent these bytes as printable characters by converting to base 64 or hexadecimal characters:

```bash
# Get 12 random bytes from /dev/urandom, output in base 64 encoding.
n=12
echo $(head -c $n /dev/urandom | base64)

# Get 12 random bytes as above, output as hex characters.
head -c $n /dev/urandom | xxd -ps
```
For anything that requires even slight security, __do not__ use the [`$RANDOM` internal Bash function][10].

If you want to generate a set of random words, you can use a random number sourced from `/dev/urandom` to lookup a word by line number in a word list provided by  the OS. In Debian/Ubuntu Linux, the `/usr/share/dict/words` file contains 99171 words, each on a separate line. [Example Bash script for creating pseudo-random word list][13].

C++
---
I've found quite a few comments on Stack Overflow in response to people asking for advice on accessing `/dev/urandom` in C++ that basically say "Why not just use an established library like OpenSSL?"

I'm not a cryptographer but I don't necessarily agree with this. If you just need some bytes that are cryptographically secure, it's pretty easy just to fetch them from `/dev/urandom`.

If you're using Linux (this repo is Linux-focused), `/dev/urandom` provides you access to the Kernel's random number generator. Effectively, accessing this file is an API to the Kernel's cryptographically secure source of randomness.

In my opinion, this does not count as _rolling your own_ crypto. Rolling your own crypto is a **bad thing** and you shouldn't do it.

```c++
...
// Get 32 bytes of randomness and display them as hexadecimal characters
int n = 32;
std::ifstream file("/dev/urandom", std::ios::binary|std::ios::in);
if (!file) {
	std::cerr << "Couldn't open /dev/urandom. Exiting..." << '\n';
	return 1;
}
std::vector<char> randomBytes(n);
file.read(&randomBytes[0], n);
for (auto& el : randomBytes)
	std::cout << std::setfill('0') << std::setw(2) << std::hex << (0xff & (unsigned int)el);
std::cout << '\n';
```
For a working example, see [cpp][14]. 

Compiling/linking OpenSSL just to get randomness is possibly overkill. You could argue that such libraries make the source of randomness somewhat obscure. Yes, they are tested - but it can be difficult to track down exactly _where_ randomness comes from. Get ready for forensic coding if you want to work this out.

OpenSSL
-------
C project that uses the `<openssl/rand.h>` library to generate random data. I found this a bit tricky to set up.

Note that in the `Makefile`, `cc` requires `-lssl -lcrypto` flags.

[RAND_][7] is used to check for sufficient entropy. Note issues re: [libgcrypt entropy loss][8]

Resources
---------
* [Linux kernel random.c file][12]: Contains extensive comments regarding the kernel CRNG
* [/dev/random vs /dev/urandom][6]
* [Base 64 Wiki article][1]
* [RFC 1421][2]: Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures
* [https://en.wikipedia.org/wiki/Binary-to-text_encoding#ASCII_armor][3]
* [https://en.wikiquote.org/wiki/John_von_Neumann][4]
* [https://github.com/DavidCWebs/radix-64-encoding][5]
* [https://www.openssl.org/docs/manmaster/man3/RAND_add.html][7]
* [Entropy Loss & Predictability, Libgcrypt PRNG][8]
* [Bash `$RANDOM` function][10]
* [Weak PRNG affected Android Bitcoin wallets in 2013][11]
* [Insane Coding: Dealing with Randomness][15]
* [Secure Programming Cookbook][16]
* [Practical Random Number Generation in Software][17]
* [How /dev/random might be improved][18]


[1]: https://en.wikipedia.org/wiki/Base64
[2]: https://tools.ietf.org/html/rfc1421
[3]: https://en.wikipedia.org/wiki/Binary-to-text_encoding#ASCII_armor
[4]: https://en.wikiquote.org/wiki/John_von_Neumann
[5]: https://github.com/DavidCWebs/radix-64-encoding
[6]: https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/
[7]: https://www.openssl.org/docs/manmaster/man3/RAND_add.html
[8]: https://formal.iti.kit.edu/~klebanov/pubs/libgcrypt-cve-2016-6313.pdf
[9]: https://github.com/DavidCWebs/generate-randomness/blob/07d057dd66b00a508acf0ee22e2cd8b36f2a67b1/urandom-c/main.c#L7
[10]: https://www.tldp.org/LDP/abs/html/randomvar.html
[11]: https://bitcoin.org/en/alert/2013-08-11-android
[12]: https://github.com/torvalds/linux/blob/master/drivers/char/random.c
[13]: bash/random-words
[14]: cpp
[15]: https://insanecoding.blogspot.com/2014/05/dealing-with-randomness.html
[16]: https://www.amazon.co.uk/Secure-Programming-Cookbook-Cryptography-Authentication/dp/0596003943/ref=sr_1_fkmr1_1?keywords=secure+coding+cookbook&qid=1567798258&s=gateway&sr=8-1-fkmr1
[17]: https://www.acsac.org/2003/papers/79.pdf
[18]: http://jlcooke.ca/random/
